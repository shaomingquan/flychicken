<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>demo</title>
    <script src="./node_modules/matter-js/build/matter.min.js" charset="utf-8"></script>
    <style media="screen">
      html, body {
        height: 100%;
        width: 100%;
        padding: 0;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="text/javascript">

// /demo/#collisionFiltering 这个例子可以用来开启隐身
// /demo/#airFriction 这个例子可做减速的debuff
// /demo/#events 这个例子用来做子弹撞击
// 用颜色代表血量
// 同步子弹数据的时候实际上是同步子弹的初始位置


      // module aliases
      window.Engine = Matter.Engine,
      window.Render = Matter.Render,
      window.World = Matter.World,
      window.Bodies = Matter.Bodies;
      window.Body = Matter.Body;
      window.Events = Matter.Events;
      window.Bounds = Matter.Bounds;
      window.Mouse = Matter.Mouse;

      // create an engine
      var engine = Engine.create();
      var world = engine.world;
      world.gravity.y = 0;

      var heightOfWorld = 2000;
      var widthOfWorld = 2000;

      world.bounds.min.x = 0;
      world.bounds.min.y = 0;
      world.bounds.max.x = widthOfWorld;
      world.bounds.max.y = heightOfWorld;



      var STATIC = { isStatic: true };
      var thicknessOfBound = 20;
      var bounds = [
        /* 上 */ Bodies.rectangle(
                  widthOfWorld / 2,
                  0,
                  widthOfWorld,
                  thicknessOfBound,
                  STATIC
                ),
        /* 下 */ Bodies.rectangle(
                  widthOfWorld / 2,
                  heightOfWorld,
                  widthOfWorld,
                  thicknessOfBound,
                  STATIC
                ),
        /* 左 */Bodies.rectangle(
                  0,
                  heightOfWorld / 2,
                  thicknessOfBound,
                  widthOfWorld,
                  STATIC
                ),
        /* 右 */Bodies.rectangle(
                  widthOfWorld,
                  heightOfWorld / 2,
                  thicknessOfBound,
                  widthOfWorld,
                  STATIC
                ),
      ]

      // create a renderer
      window.render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: 1000,
            height: 800,
            // showAngleIndicator: true,
            hasBounds: true,
            wireframes: false
        }
      });

      // mouse event
      window.mouse = Mouse.create(render.canvas)





      // create two boxes and a ground
      window.myr = 10;
      window.boxA = Bodies.rectangle(400, 200, myr * 2, myr * 2);
      window.boxA.render.fillStyle = 'rgba(255, 0, 0, 1)'
      window.boxA.render.strokeStyle = 'rgba(255, 0, 0, 0.7)'
      window.boxA.render.lineWidth = '5'
      // 视窗中心
      function updateView () {
        var boxPosition = window.boxA.position;

      }

      // add all of the bodies to the world
      World.add(engine.world, [boxA, ...bounds]);

      let codeDirectionMap = new Map();
      codeDirectionMap.set(87, 'up');
      codeDirectionMap.set(83, 'down');
      codeDirectionMap.set(65, 'left');
      codeDirectionMap.set(68, 'right');

      //     87
      // 65  83  68
      var accelerationY = 0.05;
      var accelerationX = 0.03;

      // 制动加速度
      var decelerationY = 0.1;
      var decelerationX = 0.1;

      // 阻力
      var resistanceY = 0.075;
      var resistanceX = 0.065;

      // 当前速度
      var vY = 0;
      var vX = 0;

      // 横纵的最大速度
      var maxVY = 6;
      var maxVX = 3;

      // 加速度开关
      var accY = false;
      var acc_Y = false;
      var accX = false;
      var acc_X = false;

      // 控制按键
      var whenkeyXDown = new Map();
      var whenkeyXUp = new Map();

      // 飞船是否存在动力
      var hasMotion = false;
      var getMotion = f => _ => {hasMotion = true; f()}
      var outofMotion = f => _ => {hasMotion = false; f()}
      whenkeyXDown.set('down',  getMotion(_ => accY = true));
      whenkeyXUp.set('down',    outofMotion(_ => accY = false));
      whenkeyXDown.set('up',    getMotion(_ => acc_Y = true));
      whenkeyXUp.set('up',      outofMotion(_ => acc_Y = false));
      whenkeyXDown.set('right', getMotion(_ => accX = true));
      whenkeyXUp.set('right',   outofMotion(_ => accX = false));
      whenkeyXDown.set('left',  getMotion(_ => acc_X = true));
      whenkeyXUp.set('left',    outofMotion(_ => acc_X = false));

      document.addEventListener('keydown', e => {
        var code = (e.keyCode || e.which);
        var direction = codeDirectionMap.get(code);
        if(!direction) return
        whenkeyXDown.get(direction)();
      })
      document.addEventListener('keyup', e => {
        var code = (e.keyCode || e.which);
        var direction = codeDirectionMap.get(code);
        if(!direction) return
        whenkeyXUp.get(direction)();
      })
      Events.on(engine, 'beforeUpdate', function(event) {
        if(!hasMotion) {
          if(vY !== 0) {
            let nextvY;
            if(vY > 0) {
              nextvY = vY - resistanceY;
              if(nextvY * vY < 0) {
                nextvY = 0
              }
            } else {
              nextvY = vY + resistanceY;
              if(nextvY * vY < 0) {
                nextvY = 0
              }
            }
            vY = nextvY
          }

          if(vX !== 0) {
            let nextvX;
            if(vX > 0) {
              nextvX = vX - resistanceX;
              if(nextvX * vX < 0) {
                nextvX = 0
              }
            } else {
              nextvX = vX + resistanceX;
              if(nextvX * vX < 0) {
                nextvX = 0
              }
            }
            vX = nextvX
          }
        }

        if(accY) {
          if(vY < 0) { //reverse
            vY += decelerationY;
          } else {
            vY += accelerationY;
            vY = Math.min(vY, maxVY);
          }
        }

        if(accX) {
          if(vX < 0) { //reverse
            vX += decelerationX;
          } else {
            vX += accelerationX;
            vX = Math.min(vX, maxVX);
          }
        }

        if(acc_Y) {
          if(vY > 0) { //reverse
            vY -= decelerationY;
          } else {
            vY -= accelerationY;
            vY = Math.max(vY, -maxVY);
          }
        }

        if(acc_X) {
          if(vX > 0) { //reverse
            vX -= decelerationX;
          } else {
            vX -= accelerationX;
            vX = Math.max(vX, -maxVX);
          }
        }

        var aposi = window.mouse.absolute;
        window.viewOffsetX = (aposi.x - viewportCentre.x) / 3;
        window.viewOffsetY = (aposi.y - viewportCentre.y) / 3;


        yourPositionAbs.x = viewportCentre.x + window.viewOffsetX;
        yourPositionAbs.y = viewportCentre.y + window.viewOffsetY;

        var www = aposi.x - yourPositionAbs.x;
        var hhh = aposi.y - yourPositionAbs.y;
        var ang = Math.atan(hhh / www)
        Body.setAngle(window.boxA, ang)
        // Fallow Hero X
        render.bounds.min.x = boxA.position.x - cWidth / 2 + viewOffsetX;
        render.bounds.max.x = boxA.position.x + cWidth / 2 + viewOffsetX;

        // Fallow Hero Y
        render.bounds.min.y = boxA.position.y - cHeight / 2 + viewOffsetY;
        render.bounds.max.y = boxA.position.y + cHeight / 2 + viewOffsetY;

        Body.setVelocity(boxA, {x: vX, y: vY})
        // Body.setVelocity(boxA, {x: vX / 2, y: vY / 2})
      })

      function scaletounithhhwww (hhh, www) {
        var diagonal = Math.sqrt(hhh**2 + www**2)
        return {
          unith: (hhh / diagonal) * 2.5 * myr,
          unitw: (www / diagonal) * 2.5 * myr
        }
      }

      var bullets = [];
      document.addEventListener('click', function () {
        var aposi = window.mouse.absolute;
        var www = aposi.x - yourPositionAbs.x;
        var hhh = aposi.y - yourPositionAbs.y;

        var angle = Math.atan(hhh / www)

        var { unith, unitw } = scaletounithhhwww(hhh, www);

        bulletposistart  = {
          x: window.boxA.position.x + unitw,
          y: window.boxA.position.y + unith
        }

        var bullet = Bodies.rectangle(bulletposistart.x, bulletposistart.y, myr, 3, {angle})
        // Body.setMass(bullet, 0.0001)
        bullet.render.fillStyle = 'aqua'
        Body.setVelocity(bullet, {x: unitw, y: unith})
        // bullets.push(bullet)
        var timer = setTimeout(function() {
          World.remove(engine.world, bullet)
          clearTimeout(timer)
        }, 3000)

        World.add(engine.world, [bullet])
      })

      var canvasEle = document.getElementsByTagName('canvas')[0]
      // var cWidth = canvasEle.width * 2;
      // var cHeight = canvasEle.height * 2;
      var cWidth = canvasEle.width;
      var cHeight = canvasEle.height;
      var viewportCentre = {
        x: render.options.width * 0.5,
        y: render.options.height * 0.5
      };

      var yourPositionAbs = Object.assign({}, viewportCentre);
      // run the engine
      Engine.run(engine);

      // run the renderer
      Render.run(render);
    </script>
  </body>
</html>
