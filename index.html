<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>demo</title>
    <script src="./node_modules/matter-js/build/matter.min.js" charset="utf-8"></script>
  </head>
  <body>
    <script type="text/javascript">
      // module aliases
      window.Engine = Matter.Engine,
      window.Render = Matter.Render,
      window.World = Matter.World,
      window.Bodies = Matter.Bodies;
      window.Body = Matter.Body;
      window.Events = Matter.Events;

      // create an engine
      var engine = Engine.create();
      var world = engine.world;
      world.gravity.y = 6;

      // create a renderer
      var render = Render.create({
        element: document.body,
        engine: engine
      });

      // create two boxes and a ground
      window.boxA = Bodies.circle(400, 200, 10, 10);
      var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });

      // add all of the bodies to the world
      World.add(engine.world, [boxA, ground]);

      let codeDirectionMap = new Map();
      codeDirectionMap.set(87, 'up');
      codeDirectionMap.set(83, 'down');
      codeDirectionMap.set(65, 'left');
      codeDirectionMap.set(68, 'right');

      //     87
      // 65  83  68
      var accelerationY = 0.05;
      var accelerationX = 0.03;

      // 制动加速度
      var decelerationY = 0.1;
      var decelerationX = 0.1;

      // 阻力
      var resistanceY = 0.075;
      var resistanceX = 0.065;

      // 当前速度
      var vY = 0;
      var vX = 0;

      // 横纵的最大速度
      var maxVY = 6;
      var maxVX = 3;

      // 加速度开关
      var accY = false;
      var acc_Y = false;
      var accX = false;
      var acc_X = false;

      // 控制按键
      var whenkeyXDown = new Map();
      var whenkeyXUp = new Map();

      // 飞船是否存在动力
      var hasMotion = false;
      var getMotion = f => _ => {hasMotion = true; f()}
      var outofMotion = f => _ => {hasMotion = false; f()}
      whenkeyXDown.set('down',  getMotion(_ => accY = true));
      whenkeyXUp.set('down',    outofMotion(_ => accY = false));
      whenkeyXDown.set('up',    getMotion(_ => acc_Y = true));
      whenkeyXUp.set('up',      outofMotion(_ => acc_Y = false));
      whenkeyXDown.set('right', getMotion(_ => accX = true));
      whenkeyXUp.set('right',   outofMotion(_ => accX = false));
      whenkeyXDown.set('left',  getMotion(_ => acc_X = true));
      whenkeyXUp.set('left',    outofMotion(_ => acc_X = false));

      document.addEventListener('keydown', e => {
        var code = (e.keyCode || e.which);
        var direction = codeDirectionMap.get(code);
        if(!direction) return
        whenkeyXDown.get(direction)();
      })
      document.addEventListener('keyup', e => {
        var code = (e.keyCode || e.which);
        var direction = codeDirectionMap.get(code);
        if(!direction) return
        whenkeyXUp.get(direction)();
      })
      Events.on(engine, 'beforeUpdate', function(event) {
        if(!hasMotion) {
          if(vY !== 0) {
            let nextvY;
            if(vY > 0) {
              nextvY = vY - resistanceY;
              if(nextvY * vY < 0) {
                nextvY = 0
              }
            } else {
              nextvY = vY + resistanceY;
              if(nextvY * vY < 0) {
                nextvY = 0
              }
            }
            vY = nextvY
          }

          if(vX !== 0) {
            let nextvX;
            if(vX > 0) {
              nextvX = vX - resistanceX;
              if(nextvX * vX < 0) {
                nextvX = 0
              }
            } else {
              nextvX = vX + resistanceX;
              if(nextvX * vX < 0) {
                nextvX = 0
              }
            }
            vX = nextvX
          }
        }

        if(accY) {
          if(vY < 0) { //reverse
            vY += decelerationY;
          } else {
            vY += accelerationY;
            vY = Math.min(vY, maxVY);
          }
        }

        if(accX) {
          if(vX < 0) { //reverse
            vX += decelerationX;
          } else {
            vX += accelerationX;
            vX = Math.min(vX, maxVX);
          }
        }

        if(acc_Y) {
          if(vY > 0) { //reverse
            vY -= decelerationY;
          } else {
            vY -= accelerationY;
            vY = Math.max(vY, -maxVY);
          }
        }

        if(acc_X) {
          if(vX > 0) { //reverse
            vX -= decelerationX;
          } else {
            vX -= accelerationX;
            vX = Math.max(vX, -maxVX);
          }
        }

        Body.setVelocity(boxA, {x: vX, y: vY})
        // Body.setVelocity(boxA, {x: vX / 2, y: vY / 2})
      })

      // run the engine
      Engine.run(engine);

      // run the renderer
      Render.run(render);
    </script>
  </body>
</html>
